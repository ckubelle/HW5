# HW5 Reflection - Christian Kubelle
*I pledge my honor that I have abided by the Stevens Honor System - CK*

## Design
### 1. What was most helpful about thinking about design methods of your project?
### 2. What was most difficult? What would you do differently?
### 3. What design methods might you want to try again in the future on another project?
## Implementation
### 1. What was most helpful about implementing, testing, and integration in your bot project?
The most helpful aspect of implementing our bot was that both of the APIS we used were made to be used in Python which made using the two APIS together seamless. For Redditbot, we used the discord.py API and the Praw API. The discord.py API allowed us to program commands that the bot would asynchronously listen to within Discord. Once a certain command was said within a discord channel, the bot would then perform the respective function. The Praw API allowed us to easily obtain data from reddit.com. String manipulation and data processing was very easy within Python and this allowed us to quickly be able to process data from Reddit and then send that processed data to the user using discord.py. If the APIs were meant to be used in different languages, we would have probably needed to store processed data in a text file or database which would have slowed the efficiency of the bot. Another helpful aspect of implementation was that both APIS had clear documentation of how to get started using them as well as all the functionality they gave. This reduced the learning curve that could have been more steep if the documentation was unclear. There were also some good tutorials on YouTube that allowed us to learn how to use both APIs quickly.  

In terms of testing the most helpful aspect was that we tested each other’s code in addition to the code we individually wrote. I think this helped prevent bugs from entering the main branch as well as improved the overall efficiency of our code because we had a clean viewpoint when testing each other’s code. We essentially performed black box testing which gave us unbiased testing for different commands of our bot. This allowed us to test from a user’s point-of-view rather than the designer's point-of-view which made us consider some additional enhancements we could add to the bot. For example, we added a -help command which lists all the available commands the bot can use. This is known as a design affordance. As a developer of the bot, it was obvious to us what each command meant and did but from a user point-of-view not knowing what each command does can be frustrating. 

Since my group developed this bot in a relatively short time span, integration was easy because we did not have to worry about the APIs we used changing or depreciating features. Once we wrote the base code for our bot and created the main architecture, we were able to focus on the more complex features without questioning if the base code of our bot worked. I originally thought that hosting the bot on a cloud server provider like AWS would be difficult because I thought we would have to format the code to constantly run. I originally planned to use Screen which is a terminal multiplexer that allows for multiple shells to be run at once under one terminal window. But discord.py runs the Discord bot asynchronously already which saved us the trouble having to code the bot to constantly monitor the Discord server.

### 2. What was most difficult? What would you do differently?
The most difficult part about implementation was that the features of our bot were limited to only the functionality offered by both of the APIs. What I mean by this is that sometimes we couldn’t implement features because only one API supported that functionality. For example, I wanted to implement a command that was able to download a video found on reddit and then post it within the discord server. The reddit API supported this feature however, the discord API didn’t. The discord API does not let you post videos and this meant there was nothing we could do to implement this feature for the final version of our bot. This limited the capability of the bot and was disappointing because it would have been nice to implement even more commands like this one. If we had more time, I would spend more time trying to find a solution to this problem although ultimately I don’t think there was anything we could have done. 

The hardest part about testing was doing boundary value analysis and equivalence partitioning. This method of testing was hard because in order to do this testing we needed to gather Reddit posts that were “outside” the normal boundary of input values. For example, we had a bug where the bot could not print out a message due to a Reddit post being longer than 256 characters. We did not foresee this as an issue because all posts we gathered from Reddit previous to this test were shorter than 256 characters. This error occurred far into development and we never foresaw it as an issue because there were no previous examples like this. A similar problem that occurred was that the bot would try to post an image even though there was no image to post. This happened because instead the bot mistakenly identified a video as an image and tried to post it to the user like it was one. Once again, this bug did not arise until we tested the bot pretty heavily and we previously never thought this would be an issue because all the previous tests we did did not contain a video. Looking back, I would try to create some boundary value Reddit posts myself to test our bot with. 
 
Once again, integration was not that challenging for our bot and I think that was mainly due to us choosing to use two well documented and coded APIs. The hardest part was that discord.py is an asynchronous library or module and Praw, which is the reddit supported API, is not supported to be used asynchronously. Initially this was problematic because when we tried using Praw asynchronously we got errors stating that we shouldn’t be doing so. Luckily for our group, a different developer created an asynchronous version of Praw that allowed us to gather data from Reddit asynchronously. If I were to do things  differently I would spend more time researching each API to ensure this type of error wouldn’t occur.

### 3. What implementation, testing, and integration methods might you want to try again in the future on another project?
In the future I will continue to use different APIs in conjunction with others to create software that has a lot of useful functionality. My favorite part of this project is that my group created a deployable bot that we can show to others.I plan to continue to use APIs and libraries because they can offer so much functionality and can save you time from coding things from scratch. In addition, I will continue to use different testing methods such as black box testing and boundary testing because they help find existing bugs within your code. 

## Process
### 1. What was most helpful about implementing kanban and code review in your project?
Starting with kanban, the most helpful aspect of using the workflow management method was that it allowed us as a group to keep track of all the features we had to implement while only being able to code just one or two features at a time. When developing a large application, it can be overwhelming to keep track of all the features you intend to implement and it is much easier to have one source where all these features are stored. While coding one feature, you may think of another that needs to be implemented. Or, you may find a bug that needs to be fixed. Having one location to describe all these issues to you and your teammates helped prevent important features of our project from being forgotten about. Not to mention that different developers may have different perspectives about how certain features are supposed to work, and kanban does a great job of keeping everyone on the same page since everyone can view the project board at any time. By creating issues and incorporating them on our kanban board, we were able to easily delegate work in a fair manner. During our sprint meetings, we would discuss who would like to work on a specific issue and then assign that person to that issue within kanban. It was also helpful that we could assign labels to certain issues. This allowed our group to label each task based on importance (1,3,5,8) and any other labels that were significant.

Using pull requests and reviewing each other’s code increased the overall efficiency of our bot. By using these methods we prevented unintended features from getting pushed onto our main branch. If we were working on an application used by millions of users, having an unintended feature getting pushed to the main version could be disastrous. However, by doing pull requests we were able to better understand each other’s work and fix certain parts of each other’s code that could cause bugs or errors. For example, there was one instance where a group member’s code had an unnecessary for loop which was not needed. There was another instance where the names of variables were confusing and could have been clearer. Without doing pull requests and code reviews, we may have let these non optimal aspects of our code get pushed to our main version of our bot. This is obviously not optimal.
### 2. What was most difficult? What would you do differently?
The most difficult part with the kanban board was accurately describing how each feature was to be implemented. With technical work it can be hard to describe how to implement a certain feature in words and I found that it took a long time to list each part of a feature. Personally, I had trouble describing what I envisioned in my mind onto a card or issue within kanban. I think at times my groupmates understood what I was describing over video chat and it was almost easier to just fix the issue than creating an issue on the kanban board. Creating descriptive issues on the kanban board is timely and that is my biggest complaint. Another aspect of kanban that I found was hard is the clutter that can arise within kanban. As the number of cards increase, you have to constantly scroll up or down within the columns. Additionally, I wish there was a better way to organize the cards other than by creating more columns. What I mean by this is I wish there was an inheritance like feature that allowed you to create sub cards or super cards. This feature would be useful because some cards were related to one another and it would be nice to categorize them this way. If I were to do things differently, I would create more columns related to the type of work required. For example, I would have a ‘UI’ column or a ‘Database’ column. This would help prevent one column containing a lot of tasks. Knowing what I know now, I would only include issues within the project board and not cards. The benefit to this is that you can assign people issues and not cards. You can also add longer comments, and labels. Our group started doing this mid way through the process milestone and once we made this change I think the project board was much more readable. 

I did not have that much difficulty with code review. The most difficult part was when we all git merged and had to ensure that our code worked with each other’s code. I always get worried that the work I did will get deleted whenever I git merge but luckily this did not happen. I had to do some research on how to resolve a merge conflict and by following a github tutorial I was able to resolve the conflicts and merge properly. If I were to do things differently I would simply start creating different branches more early on in development. We chose to solely work on the main branch initially because we wanted to just start coding away. But in hindsight, it may have been more wise to take the time to create different branches.

### 3. What software processes or practices might you want to try again in the future on another project?
I would definitely like to continue to use kanban or similar software that enhances workflow management in the future. For future projects I will research extensions of Github Projects that give more functionality and allow for better organization. I know that code reviews are very common in industry and I am glad to have learned how to create pull requests in class. I know that for large scale projects that are used by millions of people, code review and pull requests are very helpful for maintaining the functionality of software before it gets deployed to all users. 
 
## Overall
### 1. Considering all the design methods, implementation practices, and software processes you've encountered---compare and contrast how the benefits of the different practices and how they might be useful together.
 


